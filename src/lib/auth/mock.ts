/**
 * MOCK AUTHENTICATION SYSTEM
 * 
 * This file contains mock authentication logic for development.
 * Remove this file and update api.ts when the real backend is ready.
 * 
 * To disable mocking, set MOCK_AUTH=false in your environment variables.
 */

import type { LoginRequest, LoginResponse, User, RefreshTokenResponse } from './api';

// Mock users database
const MOCK_USERS: Record<string, { password: string; user: User }> = {
  'admin@destinacioni.com': {
    password: 'admin123',
    user: {
      id: '1',
      email: 'admin@destinacioni.com',
      name: 'Admin User',
      roles: ['admin'],
      avatar: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=100&h=100&fit=crop&crop=face',
    },
  },
  'vendor@destinacioni.com': {
    password: 'vendor123',
    user: {
      id: '2',
      email: 'vendor@destinacioni.com',
      name: 'Vendor User',
      roles: ['vendor'],
      company: 'Albania Car Rentals',
      avatar: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=100&h=100&fit=crop&crop=face',
    },
  },
  'user@destinacioni.com': {
    password: 'user123',
    user: {
      id: '3',
      email: 'user@destinacioni.com',
      name: 'Regular User',
      roles: ['user'],
      avatar: 'https://images.unsplash.com/photo-1494790108755-2616b612b786?w=100&h=100&fit=crop&crop=face',
    },
  },
};

// Mock tokens storage (in real app, these would be generated by backend)
const MOCK_TOKENS: Record<string, { access_token: string; refresh_token: string }> = {};

/**
 * Generate a mock JWT token
 */
function generateMockToken(user: User): string {
  const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));
  const payload = btoa(JSON.stringify({
    sub: user.id,
    email: user.email,
    roles: user.roles,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24 hours
  }));
  const signature = btoa('mock-signature');
  
  return `${header}.${payload}.${signature}`;
}

/**
 * Mock login function
 */
export async function mockLogin(credentials: LoginRequest): Promise<LoginResponse> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 1000));

  const userData = MOCK_USERS[credentials.email];
  
  if (!userData || userData.password !== credentials.password) {
    throw new Error('Invalid email or password');
  }

  const access_token = generateMockToken(userData.user);
  const refresh_token = generateMockToken({ ...userData.user, id: `${userData.user.id}_refresh` });

  // Store tokens for refresh functionality
  MOCK_TOKENS[userData.user.id] = { access_token, refresh_token };

  return {
    access_token,
    refresh_token,
    expires_in: 86400, // 24 hours
    user: userData.user,
  };
}

/**
 * Mock refresh token function
 */
export async function mockRefreshToken(refreshToken: string): Promise<RefreshTokenResponse> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 500));

  // Find user by refresh token (simplified)
  const userId = Object.keys(MOCK_TOKENS).find(id => 
    MOCK_TOKENS[id].refresh_token === refreshToken
  );

  if (!userId) {
    throw new Error('Invalid refresh token');
  }

  const userData = Object.values(MOCK_USERS).find(u => u.user.id === userId);
  if (!userData) {
    throw new Error('User not found');
  }

  const newAccessToken = generateMockToken(userData.user);
  const newRefreshToken = generateMockToken({ ...userData.user, id: `${userData.user.id}_refresh` });

  MOCK_TOKENS[userId] = { 
    access_token: newAccessToken, 
    refresh_token: newRefreshToken 
  };

  return {
    access_token: newAccessToken,
    refresh_token: newRefreshToken,
    expires_in: 86400,
  };
}

/**
 * Mock get current user function
 */
export async function mockGetCurrentUser(): Promise<User> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 300));

  // In a real app, this would extract user from the token
  // For mock, we'll return the first user (in real app, this comes from token)
  const userData = Object.values(MOCK_USERS)[0];
  if (!userData) {
    throw new Error('User not authenticated');
  }

  return userData.user;
}

/**
 * Mock logout function
 */
export async function mockLogout(): Promise<void> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 200));
  
  // In real app, this would invalidate tokens on server
  console.log('Mock logout completed');
}

/**
 * Mock register function
 */
export async function mockRegister(userData: {
  email: string;
  password: string;
  name: string;
  role: 'user' | 'vendor';
}): Promise<LoginResponse> {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 1500));

  if (MOCK_USERS[userData.email]) {
    throw new Error('User already exists');
  }

  const newUser: User = {
    id: Date.now().toString(),
    email: userData.email,
    name: userData.name,
    roles: [userData.role],
  };

  MOCK_USERS[userData.email] = {
    password: userData.password,
    user: newUser,
  };

  const access_token = generateMockToken(newUser);
  const refresh_token = generateMockToken({ ...newUser, id: `${newUser.id}_refresh` });

  MOCK_TOKENS[newUser.id] = { access_token, refresh_token };

  return {
    access_token,
    refresh_token,
    expires_in: 86400,
    user: newUser,
  };
}

/**
 * Mock password reset functions
 */
export async function mockRequestPasswordReset(email: string): Promise<void> {
  await new Promise(resolve => setTimeout(resolve, 800));
  
  if (!MOCK_USERS[email]) {
    // Don't reveal if email exists
    console.log('Password reset email sent (mock)');
    return;
  }
  
  console.log(`Mock password reset email sent to ${email}`);
}

export async function mockResetPassword(token: string, newPassword: string): Promise<void> {
  await new Promise(resolve => setTimeout(resolve, 600));
  console.log(`Mock password reset completed for token: ${token.substring(0, 10)}...`);
}
